#!/usr/bin/env python3

"""
Main module for ethodump-ng.

DNS From:  https://implement-dns.wizardzines.com/book/part_1

/usr/bin/../share/nmap/nselib/data/http-fingerprints.lua
"""
import argparse
import os
import queue
import select
import socket
import struct
import sys
import fcntl
import termios
import threading
import time
import tty
import random
from io import BytesIO

import netifaces

from tp_link import parse_tp_link
from ubiquiti import parse_ubiquiti
from dhip import parse_dhip
from hikvision import parse_hikvision
from arp import parse_arp, process_arp
from dhcp import *
from dns_ import parse_dns_packet, process_dns_packet
from globals import *
from http_ import detect_service_banner, parse_http, start_server, start_https_server
from icmp import parse_icmp, parse_icmpv6, process_icmpv6_packet
from igmp import parse_igmp
from mdns import parse_mdns_packet, prepare_redirect, process_mdns_packet
from mndp import parse_mndp_packet, process_mndp_packet
from netbios import parse_netbios_datagram, parse_netbios_packet
from ssdp import parse_ssdp_packet
from tcp_udp import *
from tls import find_ja3_classification, parse_tls_payload
from responses import create_igmp_membership_report, send_mdns_query

GRAB_RESOURCES = False
TARGET_IP = None

class Interface:
    """
    Class to store and initialize system interface attributes.
    """
    interface_name = None
    mac = None
    ip = None
    ipv6 = None
    gateway = None

    def __init__(self, name: str):
        self.interface_name = name
        if not self.interface_name: # This for read file mode
            self.mac = ""
            self.ip = ""
            self.gateway = ""
            return
        self.get_own_addresses()
        try:
            gateways = netifaces.gateways()
            self.gateway = gateways['default'][netifaces.AF_INET][0]
            self.gateway_mac = gateways['default']
        except KeyError:
            pass

    def get_own_addresses(self):
        """
        Method to retrieve layer 2 and 3 addressing from specified interface.
        """
        try:
            if netifaces.AF_LINK in netifaces.ifaddresses(self.interface_name):
                self.mac = netifaces.ifaddresses(self.interface_name)[netifaces.AF_LINK][0]['addr']
            if netifaces.AF_INET in netifaces.ifaddresses(self.interface_name):
                self.ip = netifaces.ifaddresses(self.interface_name)[netifaces.AF_INET][0]['addr']
            if netifaces.AF_INET6 in netifaces.ifaddresses(self.interface_name):
                ipv6_info = netifaces.ifaddresses(self.interface_name)[netifaces.AF_INET6]
                self.ipv6 = None
                for addr_info in ipv6_info:
                    ipv6_addr = addr_info.get('addr')
                    if ipv6_addr:
                        if '%' in ipv6_addr:
                            self.ipv6 = ipv6_addr.split('%')[0]
                        else:
                            self.ipv6 = ipv6_addr
                        break
        except Exception:
            print('[!] ERROR: Please check the interface name and try again.')
            sys.exit(0)

class StatusInfo:
    """
    Function to store status information related to the
    Real-Time Display.
    """
    def __init__(self, interface):
        self.interface = interface
        self.start_time = time.time()
        self.status_message = ""
        self.message_printed = False
        self.pcap_read = ""
        self.lower_status = ""

def get_terminal_size():
    try:
        TIOCGWINSZ = termios.TIOCGWINSZ
        buf = struct.pack("HHHH", 0, 0, 0, 0)
        result = fcntl.ioctl(1, TIOCGWINSZ, buf)
        rows, cols, xpixels, ypixels = struct.unpack("HHHH", result)
        return rows, cols
    except Exception as e:
        return None, None

def hide_cursor() -> None:
    """
    Function to hide the cursor.
    """
    sys.stdout.write('\x1b[?25l')
    sys.stdout.flush()

def show_cursor() -> None:
    """
    Function to show the cursor.
    """
    sys.stdout.write('\x1b[?25h')
    sys.stdout.flush()

def key_press_listener(action) -> None:
    """
    Function to listen for key presses. Target of the key
    listener thread.
    """
    old_settings = termios.tcgetattr(sys.stdin)
    try:
        tty.setcbreak(sys.stdin.fileno())

        while not flags.exit_flag:
            if select.select([sys.stdin], [], [], 0.1)[0]:
                key_pressed = sys.stdin.read(1)
                if '\x1b' in key_pressed:
                    extra_keys = sys.stdin.read(2)
                    if '[' in extra_keys:
                        key_pressed += extra_keys
                action(key_pressed)
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

def handle_key_press(key: str) -> None:
    """
    Function to commit control actions after detecting specific
    key presses.
    """
    if key == '\x1b[D': # LEFT-ARROW
        if flags.playback_speed != 1:
            flags.playback_speed -= 1
            #print(f'Playback speed: {flags.playback_speed}x ', end='\r')
            status_info.lower_status = ""
            status_info.lower_status = f'Playback speed: {flags.playback_speed}x '
    elif key == '\x1b[C': # RIGHT-ARROW
        if flags.playback_speed != 50:
            flags.playback_speed += 1
            #print(f'Playback speed: {flags.playback_speed}x ', end='\r')
            status_info.lower_status = ""
            status_info.lower_status = f'Playback speed: {flags.playback_speed}x '
    elif key == '\x1b':  # ESC key
        print("\n[!] ESC key pressed, exiting...                        ")
        flags.exit_flag = True
        flags.q_pressed = True
    elif key.isdigit() or key in key_mapping:
        if key in key_mapping:
            key = key_mapping.get(key)
        #with flags.lock:
        #sys.stdout.write('\x1b[2J\x1b[H')
        sys.stdout.write(CLEAR_SCREEN_CURSOR_TO_TOP)
        if flags.key_code == int(key):
            flags.key_code = None
            flags.device_switch = False
        else:
            if flags.key_code is not None:
                flags.device_switch = True
            else:
                flags.device_switch = False
            flags.key_code = int(key)
        flags.q_pressed = False
    elif key == ' ':  # Checking for space bar key press
        if flags.paused:
            # If currently paused, unpause and restore any previously expanded device row
            print("[+] Output unpaused                              ", end='\r')
            flags.paused = False
            flags.q_pressed = False
            if flags.paused_device_selected is not None:
                flags.key_code = flags.paused_device_selected  # Restore the expanded view of the device
                flags.paused_device_selected = None
        else:
            # If not currently paused, pause the output and remember any currently expanded device row
            print("[-] Output paused                                ", end='\r')
            flags.paused = True
            if flags.key_code is not None:
                flags.paused_device_selected = flags.key_code  # Remember the currently expanded device
                flags.key_code = None  # No device row is expanded when paused
        flags.q_pressed = False
    elif key.lower() == 'q':
        if flags.q_pressed == True:
            flags.exit_flag = True
        else:
            status_info.lower_status = ""
            print("[-] Press 'q' again to quit, spacebar to continue.", end='\r')
            flags.paused = True
            flags.q_pressed = True

def display_devices(clients_:dict, status_info: StatusInfo) -> None:
    """
    Function to print out details of the client class instances to the
    Real-Time Display. Target of thread.
    """
    # Define maximum widths for each column
    max_widths = {
        '#': 3, 'SOURCE': 19, 'IPv4': 14, 'IPv6': 30, 'MANUFACTURER': 20,
        'HOSTNAME': 20, 'SERVICES': 20, 'TTL': 4, 'MAKE/MODEL/OS': 15, 'PORTS': 6, 'COUNTS': 6
    }

    # Define the header and row formats using the maximum widths
    header_format = " ".join([f"{{:<{max_widths[col]}}}" for col in max_widths])
    header = header_format.format(*max_widths.keys())
    sys.stdout.write('\x1b[2J\x1b[H') # initial clear screen and move cursor to top left

    while not flags.exit_flag:

        if not flags.paused:

            # Get the terminal size
            rows, columns = get_terminal_size()

            clients_dict = clients_.copy()
            #with flags.lock:

            display_body = ""

            current_time = time.time()
            elapsed_time = int(current_time - status_info.start_time)
            elapsed_str = f"{elapsed_time // 60} min" if elapsed_time >= 60 else f"{elapsed_time} s"
            current_date_time = time.strftime('%Y-%m-%d %H:%M', time.localtime())

            if not flags.key_code:
                status_info.status_message = ""
                status_info.message_printed = False
            
            if flags.device_switch:
                status_info.status_message = ""
                status_info.message_printed = False
                flags.device_switch = False

            status_line = f"{status_info.interface} ][ Elapsed: {elapsed_str} ][ {current_date_time} {status_info.pcap_read} {status_info.status_message}"

            display_body += CURSOR_TO_TOP
            display_body += " " + status_line + '\n\n' 
            # Print the header
            display_body += " " + header + "\n"
            # Iterate through the clients dictionary and print each row
            for client_mac, client_data in clients_dict.items():
                if isinstance(client_data, dict):
                    for client_ip, ext_client in client_data.items():
                        client_dict = ext_client.to_dict()  # Convert the client object to a dictionary
                
                        # Prepare each value, truncate if necessary, convert None to '', and ensure alignment
                        truncated_dict = {}
                        for k, v in client_dict.items():
                            # If the field is one of 'OS', 'SERVICES', or 'PORTS' and is a set or list, take the first value
                            if k in ['SERVICES', 'PORTS', 'MAKE/MODEL/OS', 'HOSTNAME']:
                                if v:
                                    first_val = next(iter(v))  # Get the first value from the set/list
                                    truncated_dict[k] = str(first_val)[:max_widths[k]]
                                else:
                                    truncated_dict[k] = ''  # Set to empty string if the set is empty
                            else:
                                truncated_dict[k] = (str(v)[:max_widths[k]] if v is not None else '')

                        # Format and print the row
                        if flags.key_code and client_dict["#"] == flags.key_code:
                            display_body += DARK_RED
                        elif ext_client.color:
                            display_body += ext_client.color
                        formatted_row = header_format.format(*truncated_dict.values())
                        display_body += " " + formatted_row + "\n"
                        if flags.key_code and client_dict["#"] == flags.key_code:
                            if not status_info.message_printed:
                                status_info.status_message += f"][ + Device {flags.key_code} expanded"
                                status_info.message_printed = True
                            max_additional_rows = max(len(client_dict.get('SERVICES', [])), len(client_dict.get('HOSTNAME', [])), len(client_dict.get('PORTS', [])), len(client_dict.get('MAKE/MODEL/OS', []))) - 1
                            for i in range(max_additional_rows):
                                additional_row = {k: '' for k in max_widths}  # Initialize with empty strings
                                for k in ['HOSTNAME', 'SERVICES', 'PORTS', 'MAKE/MODEL/OS']:
                                    values = list(client_dict.get(k, []))
                                    if i + 1 < len(values):  # Check if there is a value to print in this additional row
                                        additional_row[k] = str(values[i + 1])[:max_widths[k]]
                                # Format and print the additional row
                                formatted_additional_row = header_format.format(*additional_row.values())
                                display_body += " " + formatted_additional_row + "\n"
                        if flags.key_code and client_dict["#"] == flags.key_code:
                            display_body += DEFAULT
                        elif ext_client.color:
                            display_body += DEFAULT
                else:
                    client_dict = client_data.to_dict()  # Convert the client object to a dictionary
                    
                    # Prepare each value, truncate if necessary, convert None to '', and ensure alignment
                    truncated_dict = {}
                    for k, v in client_dict.items():
                        # If the field is one of 'OS', 'SERVICES', or 'PORTS' and is a set or list, take the first value
                        if k in ['SERVICES', 'PORTS', 'MAKE/MODEL/OS', 'HOSTNAME']:
                            if v:
                                first_val = next(iter(v))  # Get the first value from the set/list
                                truncated_dict[k] = str(first_val)[:max_widths[k]]
                            else:
                                truncated_dict[k] = ''  # Set to empty string if the set is empty
                        else:
                            truncated_dict[k] = (str(v)[:max_widths[k]] if v is not None else '')

                    # Format and print the row
                    if flags.key_code and client_dict["#"] == flags.key_code:
                        display_body += DARK_RED
                    elif client_data.color:
                        display_body += client_data.color
                    formatted_row = header_format.format(*truncated_dict.values())
                    display_body += " " + formatted_row + "\n"
                    if flags.key_code and client_dict["#"] == flags.key_code:
                        if not status_info.message_printed:
                            status_info.status_message += f"][ + Device {flags.key_code} expanded"
                            status_info.message_printed = True
                        max_additional_rows = max(len(client_dict.get('SERVICES', [])), len(client_dict.get('HOSTNAME', [])), len(client_dict.get('PORTS', [])), len(client_dict.get('MAKE/MODEL/OS', []))) - 1
                        for i in range(max_additional_rows):
                            additional_row = {k: '' for k in max_widths}  # Initialize with empty strings
                            for k in ['HOSTNAME', 'SERVICES', 'PORTS', 'MAKE/MODEL/OS']:
                                values = list(client_dict.get(k, []))
                                if i + 1 < len(values):  # Check if there is a value to print in this additional row
                                    additional_row[k] = str(values[i + 1])[:max_widths[k]]
                            # Format and print the additional row
                            formatted_additional_row = header_format.format(*additional_row.values())
                            display_body += " " + formatted_additional_row + "\n"
                    if flags.key_code and client_dict["#"] == flags.key_code:
                        display_body += DEFAULT
                    elif client_data.color:
                        display_body += DEFAULT
            
            display_body += " " * len(header) + "\n"
            display_body += status_info.lower_status + "\n"
            display_body += "\n\n"
            sys.stdout.write(display_body)
            sys.stdout.flush()
            time.sleep(.6)  # Update every half second
        else:
            time.sleep(.6)

def load_oui() -> None:
    """
    Function to load an oui dictionary from an oui
    file. 
    """
    print('[+] Loading OUI tables')
    try:
        f_oui = open(oui_file, 'r')
        for line in f_oui:
            items = line.split(',')
            oui_table[items[1].lower()] = items[2]
    except FileNotFoundError:
        print(f'[!] File Not Found: {oui_file}')

def parse_packet(p: bytes, own_iface: Interface) -> None:
    """
    Main packet parsing function. Processes Layer 2&^ headers by addressing
    protocols, and ports. 
    """

    reader = BytesIO(p)
    eth_header = parse_eth_header(reader)
    if not eth_header:
        return

    if True: #not is_self_L2(eth_header.src_mac, own_iface.mac):
        if eth_header.src_mac not in clients:
            cur_client = clients[eth_header.src_mac] = Client(eth_header.src_mac, flags.client_count)
            flags.client_count += 1
            if not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = None
        else:
            cur_client = clients.get(eth_header.src_mac)
            # Extender detection - ensure we don't start attempting to modify attributes yet
            if not isinstance(cur_client, dict):
                if not is_multicast_or_broadcast(eth_header.dst_mac):
                    cur_client.communicants[eth_header.dst_mac] = None

        # increase packet count for this client
        if not isinstance(cur_client, dict):
            cur_client.count += 1

        if isinstance(eth_header, SPANNINGTreePacket):
            cur_client.protocols.add('SPANNING TREE')
            return

        if eth_header.eth_type == ARP_P:
            arp_packet = parse_arp(reader)
            process_arp(arp_packet, clients, flags)
            # cur_client.protocols.add('ARP') [[we moved this into the arp module]]
            return

        elif eth_header.eth_type == ETH_P:
            
            ip_header = parse_ip_header(reader)
            if not ip_header:
                return
            
            if ip_header.src_ip and is_private_ipv4(ip_header.src_ip):
                # Extender scenario - we've already re-arranged our clients dict to store a dictionary of ip:Client pairs
                if isinstance(cur_client, dict):
                    ext_client = cur_client.get(ip_header.src_ip)
                    if not ext_client:
                        clients[eth_header.src_mac][ip_header.src_ip] = Client(eth_header.src_mac, flags.client_count)
                        cur_client = clients[eth_header.src_mac][ip_header.src_ip]
                        flags.client_count += 1
                    else:
                        cur_client = ext_client
                    cur_client.count += 1
                else:
                    # Here we detect the first instance of a mac having multiple ip addresses associated with it
                    if cur_client.ip_address and cur_client.ip_address != ip_header.src_ip:
                        # dhcp discovery or request
                        if ip_header.src_ip != '0.0.0.0':
                            flags.extender_present = True
                            clients[eth_header.src_mac] = {}
                            clients[eth_header.src_mac][cur_client.ip_address] = cur_client
                            clients[eth_header.src_mac][ip_header.src_ip] = Client(eth_header.src_mac, flags.client_count)
                            flags.client_count += 1
                            cur_client = clients[eth_header.src_mac][ip_header.src_ip]
                            cur_client.count += 1
                cur_client.ip_address = ip_header.src_ip

            else:
                return

            if is_private_ipv4(ip_header.dst_ip) and not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = ip_header.dst_ip

            if ip_header.protocol == 17: # UDP
                udp_header = parse_udp_header(reader)
                if not udp_header:
                    return
                payload = reader.read(udp_header.payload_length)
                add_port(udp_header.dst_port, cur_client)
                add_ttl(ip_header.ttl, cur_client)

                if udp_header.src_port == 53: # DNS
                    dns_packet = parse_dns_packet(payload)
                    process_dns_packet(dns_packet, cur_client)
                    if not dns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('DNS')
                    return
                
                elif udp_header.src_port in [67,68]:
                    dhcp_packet = parse_dhcp_packet(payload)
                    if not dhcp_packet:
                        write_packet(p, "ethodebug.pcap")
                    match_dhcp_fingerprint(dhcp_packet, cur_client)
                    extract_dhcp_client_details(dhcp_packet, cur_client, clients)
                    cur_client.protocols.add('DHCP')
                    return

                elif udp_header.src_port == 137:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    if not nbns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-UDP-137')
                    return
                
                elif udp_header.src_port == 138:
                    nbns_packet = parse_netbios_datagram(payload)
                    if not nbns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-UDP-138')
                    return

                elif udp_header.dst_port == 1900:
                    ssdp_packet = parse_ssdp_packet(payload, cur_client, GRAB_RESOURCES)
                    if not ssdp_packet:
                        write_packet(p, "ethodebug.pcap")
                    elif ssdp_packet and TARGET_IP:
                        ssdp_queue.put((ip_header.src_ip, udp_header.src_port, payload))
                    cur_client.protocols.add('SSDP')
                    return
                    
                elif udp_header.dst_port == 5353: # MDNS
                    mdns_packet = parse_mdns_packet(payload)
                    if not mdns_packet:
                        write_packet(p, "ethodebug.pcap")
                    else:
                        process_mdns_packet(mdns_packet, cur_client)
                        if TARGET_IP and ip_header.src_ip == TARGET_IP:
                            mdns_queue.put((4,mdns_packet, eth_header.src_mac, ip_header.src_ip))
                    cur_client.protocols.add('MDNS')
                    return
                
                elif udp_header.src_port == 5678 or udp_header.dst_port == 5678:
                    mndp_packet = parse_mndp_packet(payload)
                    if not mndp_packet:
                        write_packet(p, "ethodebug.pcap")
                    else:
                        process_mndp_packet(mndp_packet, cur_client)
                    cur_client.protocols.add('MNDP')
                    return
                
                elif udp_header.src_port == 10001 or udp_header.dst_port == 10001:
                    parse_ubiquiti(payload, cur_client)
                    return
                
                elif udp_header.src_port == 20002 or udp_header.dst_port == 20002:
                    parse_tp_link(payload, cur_client)
                    return
                
                elif udp_header.dst_port == 37020 or udp_header.src_port == 37020:
                    parse_hikvision(payload, cur_client)

                elif len(payload) >= 8:
                    if payload[:8] == DHIP_HEADER:
                        parse_dhip(payload, cur_client)
                        return

            elif ip_header.protocol == 6: # TCP
                tcp_header = parse_tcp_header(reader)
                tcp_header.payload_length = ip_header.total_length - ip_header.header_length - tcp_header.header_length
                payload = reader.read(tcp_header.payload_length)
                add_port(tcp_header.dst_port, cur_client)
                add_ttl(ip_header.ttl, cur_client)

                tcp_ip_fingerprint(p, ip_header, tcp_header, cur_client)

                detect_service_banner(payload, cur_client)

                if b'GET' in payload or b'HTTP' in payload:
                    #parse_http(payload, cur_client, flags.lock, GRAB_RESOURCES)
                    http_queue.put((payload, cur_client))
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('HTTP')
                    return                

                if tcp_header.src_port == 22:
                    cur_client.protocols.add('SSH')
                    return
                
                if tcp_header.dst_port == 443: # HTTPS
                    tls_packet = parse_tls_payload(payload)
                    if not tls_packet:
                        write_packet(p, "ethodebug.pcap")
                    if tls_packet:
                        find_ja3_classification(tls_packet, cur_client)
                    cur_client.protocols.add('HTTPS')
                    return
                
                if tcp_header.src_port == 445: # SMB
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('SMB')
                    return

                if tcp_header.src_port == 139:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    if not nbns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-TCP-139')
                    return
                
            elif ip_header.protocol == 2: # IGMP
                igmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(igmp_payload_length)
                igmp_packet = parse_igmp(payload)
                if not igmp_packet:
                    write_packet(p, "ethodebug.pcap")
                cur_client.protocols.add('IGMP')
                return
            
            elif ip_header.protocol == 1: # ICMP
                cur_client.ttl = ip_header.ttl
                icmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(icmp_payload_length)
                icmp_packet = parse_icmp(payload)
                if not icmp_packet:
                    write_packet(p, "ethodebug.pcap")
                cur_client.protocols.add('ICMP')
                return
            
        elif eth_header.eth_type == ETH_IPV6 and not flags.extender_present:
            
            ipv6_header = parse_ipv6_header(reader)
            if not cur_client.ipv6_address and ipv6_header.src_ipv6 != IPV6_ANY_ADDRESS:
                cur_client.ipv6_address = ipv6_header.src_ipv6

            if ipv6_header.next_header == 17: # UDP
                udp_header = parse_udp_header(reader)
                payload = reader.read(udp_header.payload_length)
                
                if udp_header.src_port in [546,547]:
                    dhcpv6_packet = parse_dhcpv6_packet(payload)
                    if not dhcpv6_packet:
                        write_packet(p, "ethodebug.pcap")
                    else:
                        extract_dhcpv6_client_details(dhcpv6_packet, cur_client)
                    cur_client.protocols.add('DHCPv6')
                    return

                elif udp_header.dst_port == 1900:
                    ssdp_packet = parse_ssdp_packet(payload, cur_client, GRAB_RESOURCES)
                    if not ssdp_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('SSDP')
                    return

                elif udp_header.src_port == 5353: # MDNS
                    mdns_packet = parse_mdns_packet(payload)
                    if not mdns_packet:
                        write_packet(p, "ethodebug.pcap")
                    else:
                        process_mdns_packet(mdns_packet, cur_client)
                        if TARGET_IP and cur_client.ip_address and cur_client.ip_address == TARGET_IP:
                            mdns_queue.put((6,mdns_packet, eth_header.src_mac, ipv6_header.src_ipv6))
                    cur_client.protocols.add('MDNSv6')
                    return

                elif len(payload) >= 8:
                    if payload[:8] == DHIP_HEADER:
                        parse_dhip(payload, cur_client)

            elif ipv6_header.next_header == 0 or ipv6_header.next_header == 58: #ICMPv6
                icmpv6_packet = parse_icmpv6(reader)
                if not icmpv6_packet:
                    write_packet(p, "ethodebug.pcap")
                else:
                    process_icmpv6_packet(icmpv6_packet, cur_client)
                cur_client.protocols.add('ICMPv6')
                return
        
        elif eth_header.eth_type == REALTEK_L2_P:
            cur_client.protocols.add('REALTEK_LAYER_2')
            cur_client.services.add('L2 Switch')
        
        else:
            write_packet(p, "ethodebug.pcap")

def packet_reader(filename: str):
    """
    One of main threads. Function to read packets from file
    """
    header = None
    fcs_num_bytes = 0
    fcs_present = 0

    with open(filename, 'rb') as in_f:
        header = in_f.read(24)
        if len(header) < 24:
            print("ERROR: Incomplete file header.")
            flags.exit_flag = True
            return False

        # Unpack the global header
        magic, version_major, version_minor, thiszone, sigfigs, snaplen, linktype = struct.unpack('IHHIIII', header)

        linktype = linktype & 0x0FFFFFFF
        fcs_present = linktype & 0x10000000
        fcs_num_bytes = (linktype & 0xF0000000) << 1

        # Determine the file's endianness
        if magic == MAGIC:
            endianness = "<"  # Little endian
        elif magic == CIGAM:
            endianness = ">"  # Big endian
        else:
            print(f"ERROR: Unrecognized magic number: {magic}")
            flags.exit_flag = True
            return False

        count = 0
        ts_prev = None

        while not flags.exit_flag:
            pkt_header = in_f.read(16)
            if len(pkt_header) < 16:
                if len(pkt_header) == 0:
                    break  # End of file
                else:
                    print("ERROR: Incomplete packet header.")
                    break

            ts_s, ts_m, cap_len, orig_len = struct.unpack(endianness + 'IIII', pkt_header)
            ts_cur = ts_s + ts_m / 1e6  # Convert microseconds part to seconds and add

            pkt = in_f.read(cap_len)
            if len(pkt) < cap_len:
                print("ERROR: Incomplete packet data.")
                break

            # Handling Frame Check Sequence (FCS) if present
            if fcs_present:
                pkt = pkt[:-fcs_num_bytes]

            packet_queue.put(pkt)
            count += 1

            status_info.pcap_read = f"][ Packets read: {count}"

            if ts_prev is not None:
                try:
                    time.sleep((ts_cur - ts_prev) / flags.playback_speed)  # Sleep for the duration between the current and previous packet
                except ValueError:
                    time.sleep(abs(ts_cur - ts_prev) / flags.playback_speed) # This is an exception for instances where packet timestamps are goofed

            ts_prev = ts_cur
    
    flags.exit_flag = True

def packet_parser(iface: Interface) -> None:
    """
    One of main threads. Function pulls packets from the queue
    for parsing. 
    """
    while not flags.exit_flag:
        try:
            pkt = packet_queue.get(timeout=1)  # Timeout ensures that the loop checks the flag periodically
            parse_packet(pkt, iface)
            packet_queue.task_done()
        except queue.Empty:
            continue  # Continue checking the flag if the queue is empty

def packet_writer(filename: str | None) -> None:
    """
    One of main threads. Function pulls packets from dedicated queue
    for writing to file.
    """
    while flags.write_wait:
        try:
            pkt = write_queue.get(timeout=1)
            write_packet(pkt, filename)
            write_queue.task_done()
        except queue.Empty:
            continue

def packet_listener(iface: Interface, filename: str | None):
    """
    One of main theads. Function reads raw packets from a socket,
    then writing them to a parsing and writing queue. 
    """
    s = None
    try:
        s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
        s.bind((iface.interface_name, 0))
        print('[.] Listening for packets....')

        while not flags.exit_flag:
            pkt, addr = s.recvfrom(8192)
            packet_queue.put(pkt)
            if filename:
                write_queue.put(pkt)
    
    except KeyboardInterrupt:
        flags.exit_flag = True  # Signal all threads to exit
        print('\nCTRL+C pressed, shutting down...')
    except PermissionError:
        flags.exit_flag = True
        print('Permission Error: This script must be run with sudo.')
    except OSError:
        flags.exit_flag = True
        print(f'Error: Issue opening the socket on {iface.interface_name}.')
    finally:
        if s:
            s.close()

def write_packet(p: bytes, filename: str | None) -> None:
    """
    Function to write packets to a pcap file.
    """
    # Get the current time
    current_time = time.time()

    # Split the time into seconds and microseconds
    ts_seconds = int(current_time)
    ts_microseconds = int((current_time - ts_seconds) * 1_000_000)

    packet_length = len(p)
    packet_header = struct.pack('IIII', ts_seconds, ts_microseconds, packet_length, packet_length)
    f_out = open(filename, 'ab')
    f_out.write(packet_header)
    f_out.write(p)
    f_out.close()

def write_header(filename: str) -> None:
    """
    Function to write the global pcap file header.
    """
    f_out = open(filename, "wb")
    f_out.write(PCAP_GLOBAL_HEADER_ETHERNET)
    f_out.close()

def ssdp_responder(own_iface: Interface, red_object: RedirectObject) -> None:
    """
    Function to handle ssdp advertisements
    """
    uuid = UUID_K
    urn = None
    while not flags.exit_flag:
        try:
            (ip_src, src_port, payload) = ssdp_queue.get(timeout=1)
            payload = payload.decode('utf-8', 'ignore')
            lines = re.split(r'\r?\n', payload)
            for line in lines:
                if 'ST:' in line:
                    urn = line.replace('ST:','').strip()
            if 'SEARCH' in payload and urn:
                timenow = time.gmtime()
                # Format the current time to the specified format
                formatted_time = time.strftime("%a, %d %b %Y %H:%M:%S GMT", timenow)
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                    # Bind the socket to the interface and port
                    sock.bind(("", random.randint(49152,65535)))
                    response = f"""HTTP/1.1 200 OK\r
CACHE-CONTROL: max-age=1800\r
DATE: {formatted_time}\r
EXT: \r
LOCATION: http://{red_object.redirect_ip}:{red_object.redirect_port}{redirect_object.redirect_path}\r
SERVER: Sony-Linux/4.1, UPnP/1.0, Sony_UPnP_SDK/1.0\r
ST: {urn}\r
NTS: ssdp:alive\r
USN: uuid:{uuid}::{urn}\r
Content-Length: 0\r
BOOTID.UPNP.ORG: 52\r\n\r\n"""
                
                    sock.sendto(response.encode(), (ip_src, src_port))
            ssdp_queue.task_done()

        except queue.Empty:
            continue

def mdns_redirect(own_iface: Interface, red_object: RedirectObject) -> None:
    """
    Function to handle mnds interactions for redirection
    """
    try:
        # Create a UDP socket
        mdns_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, 0x0800)
        mdns_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BINDTODEVICE, bytes(own_iface.interface_name, 'utf-8'))
        mdns_socket.bind((own_iface.interface_name, 0))
    except OSError as e:
        print(f'[!] ERROR: Problem creating socket on {own_iface.interface_name} for sending mdns traffic.')
        return

    while not flags.exit_flag:
        try:
            ipv, pkt, dst_mac, dst_ip = mdns_queue.get(timeout=1)
            prepare_redirect(mdns_socket, ipv, dst_mac, dst_ip, pkt, own_iface, red_object)
            mdns_queue.task_done()

        except queue.Empty:
            continue

    mdns_socket.close()

def handle_http() -> None:
    while not flags.exit_flag:
        try:
            payload, cur_client = http_queue.get(timeout=1)
            parse_http(payload, cur_client, GRAB_RESOURCES)
        except queue.Empty:
            continue

if __name__ == "__main__":

    ed_argparse = argparse.ArgumentParser(prog='ethodump-ng', description='An Ethernet packet sniffing tool.')
    ed_argparse.version = '1.0'
    ed_argparse.add_argument('-i', '--interface', action='store', type=str, help='Enter the interface on which you want to sniff.', required=False)
    ed_argparse.add_argument('-w', '--write', action='store', type=str, help='Pass the file name to write packets.', required=False)
    ed_argparse.add_argument('-s', '--save', action='store', type=str, help='Pass the file name to save detailed results.', required=False)
    ed_argparse.add_argument('-r', '--resource-grab', action='store_true', help='Enable resource grabbing (Performs GET against resource urns).', required=False, default=False)
    ed_argparse.add_argument('-p', '--read-pcap', action='store', type=str, help='Pass a pcap file to read', required=False)
    ed_argparse.add_argument('-m', '--redirect', action='store', type=str, help='Enter the filename/path for redirection configuration.', required=False, default=None)
    ed_argparse.add_argument('-d', '--debug', action='store_true', help='Set the script debug to verbose.', required=False, default=False)
    ed_argparse.add_argument('-v', '--version', action='version')

    args = ed_argparse.parse_args()

    iface = None
    interface_name = ""
    # Set queues to None
    write_queue = None
    packet_queue = None
    # Number of packet processing threads
    num_workers = 4
    # Initialize threads to Null
    write_thread = None
    worker_thread = None
    listener_thread = None
    display_thread = None
    keypress_thread = None
    mdns_redirect_thread = None
    ssdp_thread = None
    http_server_thread = None
    redirect_object = None

    query_socket = None

    if not args.interface and not args.read_pcap:
        print('ERROR: either --interface or --read must be specified.')
        sys.exit()

    if args.interface:
        interface_name = args.interface

    load_tcp_fp_dbase()
    load_oui()

    if args.redirect:
        redirect_object = load_redirect_yaml(args.redirect)
        TARGET_IP = redirect_object.target_ip

    GRAB_RESOURCES = args.resource_grab

    # Initialize global interface object class
    iface = Interface(interface_name)
    # Initialize global display status info and input control class
    status_info = StatusInfo(interface_name)
    # Initialize global flags class for signal management
    flags = Flags()
    # Initialize the queue(s)
    packet_queue = queue.Queue(QUEUE_SIZE)
    # Set the threading lock
    flags.lock = threading.Lock()

    hide_cursor()

    # temporary development mode measure
    if True:
        write_header("ethodebug.pcap")

    if args.read_pcap:
        GRAB_RESOURCES = False
        if not os.path.exists(args.read_pcap):
            print(f'ERROR: File does not exist: {args.read_pcap}.')
            sys.exit()
        status_info.interface = os.path.basename(args.read_pcap)

    if args.write:
        write_header(args.write)
        write_queue = queue.Queue(QUEUE_SIZE)
        write_thread = threading.Thread(target=packet_writer, args=(args.write,), daemon=True).start()

    # Start parser threads
    for _ in range(num_workers):
        worker_thread = threading.Thread(target=packet_parser, args=(iface,), daemon=True).start()

    if args.read_pcap:
        # start the read thread
        read_thread = threading.Thread(target=packet_reader, args=(args.read_pcap,), daemon=True).start()

    if not args.read_pcap:
        # Start the listener thread
        listener_thread = threading.Thread(target=packet_listener, args=(iface,args.write,), daemon=True).start()

    if not args.debug:
        # Start the display thread
        display_thread = threading.Thread(target=display_devices, args=(clients, status_info,), daemon=True).start()

    # Start the key press listener thread
    keypress_thread = threading.Thread(target=key_press_listener, args=(handle_key_press,), daemon=True).start()

    if args.redirect and not args.read_pcap:
        mdns_redirect_thread = threading.Thread(target=mdns_redirect, args=(iface, redirect_object,), daemon=True).start()
        ssdp_thread = threading.Thread(target=ssdp_responder, args=(iface, redirect_object,), daemon=True).start()

        # If redirection is to this application, enable the http and https servers
        if redirect_object.redirect_ip == iface.ip:
            http_server_thread = threading.Thread(target=start_server, args=(redirect_object,), daemon=True).start()
            
            # only start the https server if port, key, and cert file are defined from the config
            if redirect_object.redirect_port_https and redirect_object.key_file and redirect_object.cert_file:
                https_server_thread = threading.Thread(target=start_https_server, args=(redirect_object,), daemon=True).start()

    # Thread to parse http/tcp payloads for json, xml, and other juicy tidbits
    http_thread = threading.Thread(target=handle_http, daemon=True).start()

    if args.redirect and not args.read_pcap:
        try:
            # Create a UDP socket
            query_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, 0x0800)
            query_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BINDTODEVICE, bytes(iface.interface_name, 'utf-8'))
            query_socket.bind((iface.interface_name, 0))
        except OSError as e:
            print(f'[!] ERROR: Problem creating socket on {iface.interface_name} for sending query/report packets.')

    try:
        while not flags.exit_flag:
            time.sleep(10)
            if args.redirect and not args.read_pcap:
                create_igmp_membership_report(iface, query_socket)
                send_mdns_query(iface, query_socket)
            pass

    except KeyboardInterrupt:
        flags.exit_flag = True
        print("\nCTRL+C pressed, shutting down...")
    
    if not args.read_pcap and query_socket:
        query_socket.close()

    if write_thread:
        packets_left = write_queue.qsize()
        while write_queue.qsize() > 0:
            sys.stdout.write(f'\rFinishing writing packets to file: {write_queue.qsize() - 1}/{packets_left}     ')
            sys.stdout.flush()
        sys.stdout.write('\n\r')
        flags.write_wait = False
        write_thread.join(timeout=0.1)

    if args.debug:
        for client in clients:
            if isinstance(clients[client], dict):
                for ip, ext_client in clients[client].items():
                    print(ext_client)
                continue
            print(clients[client])

    if args.save:
        f_save = open(args.save, 'w')
        for client in clients:
            if isinstance(clients[client], dict):
                for ip, ext_client in clients[client].items():
                    f_save.write(str(ext_client) + '\n')
                continue
            f_save.write(str(clients[client]) + '\n')
        f_save.close()
    
    show_cursor()
