#!/usr/bin/env python3

"""
DNS From:  https://implement-dns.wizardzines.com/book/part_1
"""

import socket
import struct
import re
import sys
import time
import argparse
import netifaces
import threading
import queue
import ipaddress
from io import BytesIO

import tty
import termios
import select

from arp import parse_arp, process_arp
from dns import parse_dns_packet, process_dns_packet
from dhcp import parse_dhcp_packet, parse_dhcpv6_packet, \
    extract_dhcp_client_details, match_dhcp_fingerprint
from tcp_udp import parse_eth_header, parse_ip_header, \
    parse_tcp_header, parse_udp_header, parse_ipv6_header
from igmp import parse_igmp
from icmp import parse_icmp, parse_icmpv6
from netbios import parse_netbios_packet
from ssdp import parse_ssdp_packet
from globals import Client, oui_table, oui_file, clients
from globals import ETH_P, ARP_P, ETH_P_ALL, ETH_IPV6
from globals import PCAP_GLOBAL_HEADER_ETHERNET, QUEUE_SIZE

# Global flag to signal threads to exit
class Flags:
    def __init__(self):         
        self.exit_flag = False
        self.key_code = None
        self.client_count = 1
        self.paused = False
        self.paused_device_selected = None
        self.device_switch = False
        self.q_pressed = False

class interface:
    interface_name = None
    mac = None
    ip = None
    gateway = None

    def __init__(self, name):
        self.interface_name = name
        self.get_own_addresses()
        try:
            gateways = netifaces.gateways()
            self.gateway = gateways['default'][netifaces.AF_INET][0]
            self.gateway_mac = gateways['default']
        except KeyError:
            pass

    def get_own_addresses(self):
        self.mac = netifaces.ifaddresses(self.interface_name)[netifaces.AF_LINK][0]['addr']
        self.ip = netifaces.ifaddresses(self.interface_name)[netifaces.AF_INET][0]['addr']


class StatusInfo:
    def __init__(self, interface):
        self.interface = interface
        self.start_time = time.time()
        self.status_message = ""
        self.message_printed = False

def debug_to_log(payload):
    f_open = open('debug.log', 'ab')
    f_open.write(payload)
    f_open.close()

def key_press_listener(action):

    old_settings = termios.tcgetattr(sys.stdin)
    try:
        tty.setcbreak(sys.stdin.fileno())

        while not flags.exit_flag:
            if select.select([sys.stdin], [], [], 0.1)[0]:
                key_pressed = sys.stdin.read(1)
                if key_pressed:
                    action(key_pressed)
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

def handle_key_press(key):

    if key == '\x1b':  # ESC key
        print("ESC key pressed, exiting...")
        flags.exit_flag = True
        flags.q_pressed = True
    elif key.isdigit():
        if flags.key_code == int(key):
            flags.key_code = None
            flags.device_switch = False
        else:
            if flags.key_code is not None:
                flags.device_switch = True
            else:
                flags.device_switch = False
            flags.key_code = int(key)
        flags.q_pressed = True
    elif key == ' ':  # Checking for space bar key press
        if flags.paused:
            # If currently paused, unpause and restore any previously expanded device row
            print("[-] Output unpaused")
            flags.paused = False
            if flags.paused_device_selected is not None:
                flags.key_code = flags.paused_device_selected  # Restore the expanded view of the device
                flags.paused_device_selected = None
        else:
            # If not currently paused, pause the output and remember any currently expanded device row
            print("[+] Output paused")
            flags.paused = True
            if flags.key_code is not None:
                flags.paused_device_selected = flags.key_code  # Remember the currently expanded device
                flags.key_code = None  # No device row is expanded when paused
        flags.q_pressed = True
    elif key.lower() == 'q':  # Checking for 'c' or 'C'
        if flags.q_pressed == True:
            flags.exit_flag = True
        else:
            print("[!] Press 'q' again to quit. Press spacebar to continue.")
            flags.paused = True
            flags.q_pressed = True
    else:
        flags.q_pressed = True

def display_devices(clients_, status_info):
    
    # Define maximum widths for each column
    max_widths = {
        '#': 3, 'SOURCE': 19, 'IPv4': 14, 'IPv6': 30, 'MANUFACTURER': 20,
        'HOSTNAME': 20, 'SERVICES': 20, 'TTL': 4, 'OS': 15, 'CONNECTIONS': 15, 'PORTS': 6, 'COUNTS': 6
    }

    # Define the header and row formats using the maximum widths
    header_format = " ".join([f"{{:<{max_widths[col]}}}" for col in max_widths])
    header = header_format.format(*max_widths.keys())
    
    while not flags.exit_flag:

        clients_dict = clients_.copy()

        if not flags.paused:
            current_time = time.time()
            elapsed_time = int(current_time - status_info.start_time)
            elapsed_str = f"{elapsed_time // 60} min" if elapsed_time >= 60 else f"{elapsed_time} s"
            current_date_time = time.strftime('%Y-%m-%d %H:%M', time.localtime())

            if not flags.key_code:
                status_info.status_message = ""
                status_info.message_printed = False
            if flags.device_switch:
                status_info.status_message = ""
                status_info.message_printed = False
                flags.device_switch = False

            status_line = f"{status_info.interface} ][ Elapsed: {elapsed_str} ][ {current_date_time} {status_info.status_message}"

            sys.stdout.write('\x1b[2J\x1b[H')  # Clear screen and move cursor to top
            sys.stdout.write(' ' + status_line + '\n\n')
            # Print the header
            sys.stdout.write(' ' + header + '\n')
            
            # Iterate through the clients dictionary and print each row
            for client_mac, client_data in clients_dict.items():
                client_dict = client_data.to_dict()  # Convert the client object to a dictionary
                
                # Prepare each value, truncate if necessary, convert None to '', and ensure alignment
                truncated_dict = {}
                for k, v in client_dict.items():
                    # If the field is one of 'OS', 'SERVICES', or 'PORTS' and is a set or list, take the first value
                    if k in ['SERVICES', 'PORTS', 'OS', 'HOSTNAME', 'CONNECTIONS']:
                        if v:
                            first_val = next(iter(v))  # Get the first value from the set/list
                            truncated_dict[k] = str(first_val)[:max_widths[k]]
                        else:
                            truncated_dict[k] = ''  # Set to empty string if the set is empty
                    else:
                        truncated_dict[k] = (str(v)[:max_widths[k]] if v is not None else '')

                # Format and print the row
                formatted_row = header_format.format(*truncated_dict.values())
                sys.stdout.write(' ' + formatted_row + '\n')
                sys.stdout.flush()
                if flags.key_code and client_dict["#"] == flags.key_code:
                    if not status_info.message_printed:
                        status_info.status_message += f"][ + Device {flags.key_code} expanded"
                        status_info.message_printed = True
                    max_additional_rows = max(len(client_dict.get('SERVICES', [])), len(client_dict.get('HOSTNAME', [])), len(client_dict.get('PORTS', [])), len(client_dict.get('OS', [])), len(client_dict.get('CONNECTIONS', []))) - 1
                    for i in range(max_additional_rows):
                        additional_row = {k: '' for k in max_widths}  # Initialize with empty strings
                        for k in ['HOSTNAME', 'SERVICES', 'PORTS', 'OS', 'CONNECTIONS']:
                            values = list(client_dict.get(k, []))
                            if i + 1 < len(values):  # Check if there is a value to print in this additional row
                                additional_row[k] = str(values[i + 1])[:max_widths[k]]
                        # Format and print the additional row
                        formatted_additional_row = header_format.format(*additional_row.values())
                        sys.stdout.write(' ' + formatted_additional_row + '\n')
                        sys.stdout.flush()
            sys.stdout.flush()
            time.sleep(1)  # Update every second
        else:
            pass

def is_multicast_or_broadcast(mac_address):
    """Check if the MAC address is multicast or broadcast."""
    if mac_address == 'ff:ff:ff:ff:ff:ff':
        return True  # Broadcast address
    # Split the MAC address string into octets and take the first one
    first_octet_str = mac_address.split(':')[0]  # Assuming MAC address is separated by ':'
    # Convert the first octet to an integer
    first_octet_int = int(first_octet_str, 16)  # Convert from hexadecimal to integer
    # Multicast address check (LSB of first octet is 1)
    return (first_octet_int & 0x01) == 0x01

def extract_os_from_user_agent(user_agent):
    # If no OS match, try to return the portion inside the first set of parentheses
    parenthetical_match = re.search(r'\(([^)]+)\)', user_agent)
    if parenthetical_match:
        return parenthetical_match.group(1)
    
    return ""

def load_oui():
    print('[+] Loading OUI tables')
    try:
        f_oui = open(oui_file, 'r')
        for line in f_oui:
            items = line.split(',')
            oui_table[items[1].lower()] = items[2]
    except FileNotFoundError:
        print(f'[!] File Not Found: {oui_file}')

def is_self_L2(packet_mac, iface_mac):
    if packet_mac == iface_mac:
        return True
    else:
        return False
    
def is_self_L2_L3(packet_mac, iface, packet_ip):

    if packet_mac == iface.mac and packet_ip == iface.ip:
        return True
    else:
        return False

def is_private_ipv4(ip_str):
    try:
        ip = ipaddress.ip_address(ip_str)
        if ip.is_private:
            return True
        # If the IP address is not private or reserved, it's considered public
        return False
    except ValueError:
        # The input is not a valid IP address
        return False
    
def add_port(src_port, cur_client):
    if src_port < 5500:
        cur_client.ports.add(src_port)

def find_ua(payload, cur_client):
    os_string = ""
    user_agent = ""

    user_agent_start = payload.find(b'User-Agent: ')
    if user_agent_start != -1:  # User-Agent header found
        # Find the end of the line starting from the User-Agent position
        user_agent_end = payload.find(b'\r\n', user_agent_start)
        if user_agent_end != -1:
            # Extract the User-Agent value, excluding 'User-Agent: ' (12 bytes)
            user_agent = payload[user_agent_start + 12:user_agent_end].decode('utf-8', 'ignore')
            os_string = extract_os_from_user_agent(user_agent)
    if user_agent:
        cur_client.user_agents.add(user_agent)
    if os_string:
        cur_client.oses.add(os_string)

def parse_packet(p, own_iface):

    reader = BytesIO(p)
    eth_header = parse_eth_header(reader)

    if not is_self_L2(eth_header.src_mac, own_iface.mac):
        if eth_header.src_mac not in clients:
            cur_client = clients[eth_header.src_mac] = Client(eth_header.src_mac, flags.client_count)
            flags.client_count += 1
            if not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = None
        else:
            cur_client = clients.get(eth_header.src_mac)

        # increase packet count for this client
        cur_client.count += 1

        if eth_header.eth_type == ARP_P:
            arp_packet = parse_arp(reader)
            process_arp(arp_packet, clients, flags)
            cur_client.protocols.add('ARP')
            return

        elif eth_header.eth_type == ETH_P:
            
            ip_header = parse_ip_header(reader)
            
            if is_private_ipv4(ip_header.src_ip):
                cur_client.ip_address = ip_header.src_ip

            if ip_header.protocol == 17: # UDP
                udp_header = parse_udp_header(reader)
                payload = reader.read(udp_header.payload_length)
                add_port(udp_header.src_port, cur_client)

                if udp_header.src_port == 53: # DNS
                    dns_packet = parse_dns_packet(payload)
                    #print(dns_packet)
                    cur_client.protocols.add('DNS')
                    return
                
                elif udp_header.src_port == 68:
                    dhcp_packet = parse_dhcp_packet(payload)
                    match_dhcp_fingerprint(dhcp_packet, cur_client)
                    extract_dhcp_client_details(dhcp_packet, cur_client)
                    cur_client.protocols.add('DHCP')
                    return

                elif udp_header.src_port == 137 or udp_header.dst_port == 137:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    cur_client.protocols.add('NETBIOS-UDP-137')
                    return
                
                elif udp_header.src_port == 138 or udp_header.dst_port == 138:
                    # print('NETBIOS on port 138')
                    cur_client.protocols.add('NETBIOS-UDP-138')
                    return

                elif udp_header.dst_port == 1900:
                    ssdp_packet = parse_ssdp_packet(payload, cur_client)
                    cur_client.protocols.add('SSDP')
                    #print(ssdp_packet)
                    return
                    
                elif udp_header.dst_port == 5353: # MDNS
                    mdns_packet = parse_dns_packet(payload)
                    process_dns_packet(mdns_packet, cur_client)
                    cur_client.protocols.add('MDNS')
                    return

            elif ip_header.protocol == 6: # TCP
                cur_client.ttl = ip_header.ttl
                tcp_header = parse_tcp_header(reader)
                tcp_header.payload_length = ip_header.total_length - ip_header.header_length - tcp_header.header_length
                payload = reader.read(tcp_header.payload_length)
                add_port(tcp_header.src_port, cur_client)

                if tcp_header.dst_port == 80: # HTTP
                    find_ua(payload, cur_client)
                    cur_client.protocols.add('HTTP')
                    return
                
                if tcp_header.dst_port == 443: # HTTPS
                    cur_client.protocols.add('HTTPS')
                    return
                
                if tcp_header.src_port == 445 or tcp_header.dst_port == 445: # SMB
                    cur_client.protocols.add('SMB')
                    return

                if tcp_header.src_port == 139:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    #print(nbns_packet)
                    cur_client.protocols.add('NETBIOS-TCP-139')
                    return
                
            elif ip_header.protocol == 2: # IGMP
                igmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(igmp_payload_length)
                igmp_packet = parse_igmp(payload)
                #print(igmp_packet)
                cur_client.protocols.add('IGMP')
                return
            
            elif ip_header.protocol == 1: # ICMP
                cur_client.ttl = ip_header.ttl
                icmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(icmp_payload_length)
                icmp_packet = parse_icmp(payload)
                #print(icmp_packet)
                cur_client.protocols.add('ICMP')
                return
            
        elif eth_header.eth_type == ETH_IPV6:
            
            ipv6_header = parse_ipv6_header(reader)
            if not cur_client.ipv6_address:
                cur_client.ipv6_address = ipv6_header.src_ipv6

            if ipv6_header.next_header == 17: # UDP
                udp_header = parse_udp_header(reader)
                payload = reader.read(udp_header.payload_length)

                if udp_header.src_port == 5353: # MDNS
                    mdns_packet = parse_dns_packet(payload)
                    process_dns_packet(mdns_packet, cur_client)
                    cur_client.protocols.add('MDNSv6')
                    return
                
                if udp_header.src_port == 546:
                    dhcpv6_packet = parse_dhcpv6_packet(payload)
                    cur_client.protocols.add('DHCPv6')
                    return
                
            elif ipv6_header.next_header == 0: #ICMPv6
                icmpv6_packet = parse_icmpv6(reader)
                cur_client.protocols.add('ICMPv6')
                return
            
# parser function to process packets
def packet_parser(iface):
    while not flags.exit_flag:
        try:
            pkt = packet_queue.get(timeout=1)  # Timeout ensures that the loop checks the flag periodically
            parse_packet(pkt, iface)
            packet_queue.task_done()
        except queue.Empty:
            continue  # Continue checking the flag if the queue is empty

def packet_writer(filename):
    while not flags.exit_flag:
        try:
            pkt = write_queue.get(timeout=1)
            write_packet(pkt, filename)
            write_queue.task_done()
        except queue.Empty:
            continue

# listener function to read packets
def packet_listener(iface, filename):
    # global exit_flag
    s = None
    try:
        s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
        s.bind((iface.interface_name, 0))
        print('[.] Listening for packets....')

        while not flags.exit_flag:
            pkt, addr = s.recvfrom(8192)
            packet_queue.put(pkt)
            if filename:
                write_queue.put(pkt)
    
    except KeyboardInterrupt:
        flags.exit_flag = True  # Signal all threads to exit
        print('\nExiting...')
    except PermissionError:
        flags.exit_flag = True
        print('Permission Error: This script must be run with sudo.')
    except OSError:
        flags.exit_flag = True
        print(f'Error: Issue opening the socket on {iface.interface_name}.')
    finally:
        if s:
            s.close()

def write_packet(p, filename):

    # Get the current time
    current_time = time.time()

    # Split the time into seconds and microseconds
    ts_seconds = int(current_time)
    ts_microseconds = int((current_time - ts_seconds) * 1_000_000)

    packet_length = len(p)
    packet_header = struct.pack('IIII', ts_seconds, ts_microseconds, packet_length, packet_length)
    f_out = open(filename, 'ab')
    f_out.write(packet_header)
    f_out.write(p)
    f_out.close()

def write_header(filename):
    f_out = open(filename, "wb")

    f_out.write(PCAP_GLOBAL_HEADER_ETHERNET)
    f_out.close()

if __name__ == "__main__":

    ed_argparse = argparse.ArgumentParser(prog='ethodump-ng', description='An Ethernet packet sniffing tool.')
    ed_argparse.version = '1.0'
    ed_argparse.add_argument('-i', '--interface', action='store', type=str, help='Enter the interface on which you want to sniff.', required=True)
    ed_argparse.add_argument('-w', '--write', action='store', type=str, help='Pass the file name to write packets.', required=False)
    ed_argparse.add_argument('-s', '--save', action='store', type=str, help='Pass the file name to save detailed results.', required=False)
    ed_argparse.add_argument('-d', '--debug', action='store_true', help='Set the script debug to verbose.', required=False, default=False)
    ed_argparse.add_argument('-v', '--version', action='version')

    args = ed_argparse.parse_args()

    load_oui()

    iface = interface(args.interface)

    status_info = StatusInfo(args.interface)

    flags = Flags()

    # Initialize the queue
    packet_queue = queue.Queue(QUEUE_SIZE)

     # Number of consumer threads
    num_workers = 4

    if args.write:
        write_header(args.write)
        write_queue = queue.Queue(QUEUE_SIZE)
        write_thread = threading.Thread(target=packet_writer, args=(args.write,))
        write_thread.daemon = True
        write_thread.start()

    # Start parser threads
    for _ in range(num_workers):
        worker_thread = threading.Thread(target=packet_parser, args=(iface,))
        worker_thread.daemon = True  # Daemon threads exit when the main program does
        worker_thread.start()

    # Start the listener thread
    listener_thread = threading.Thread(target=packet_listener, args=(iface,args.write,))
    listener_thread.daemon = True
    listener_thread.start()

    if not args.debug:
        # Start the display thread
        display_thread = threading.Thread(target=display_devices, args=(clients, status_info,))
        display_thread.daemon = True  # Daemon thread will exit when main program exits
        display_thread.start()

    # Start the key press listener thread
    keypress_thread = threading.Thread(target=key_press_listener, args=(handle_key_press,))
    keypress_thread.daemon = True  # Daemon threads will be killed when the main thread exits
    keypress_thread.start()

    try:
        # Wait for threads to exit gracefully
        while threading.active_count() > 1:
            for thread in threading.enumerate():
                if thread is not threading.current_thread():
                    thread.join(timeout=0)
    except KeyboardInterrupt:
        flags.exit_flag = True  # Signal all threads to exit
        print("\nSignal received, shutting down...")

    if args.debug:
        for client in clients:
            print(clients[client])

    if args.save:
        f_save = open(args.save, 'w')
        for client in clients:
            f_save.write(str(clients[client]) + '\n')
        f_save.close()