#!/usr/bin/env python3

"""
Main module for ethodump-ng.

DNS From:  https://implement-dns.wizardzines.com/book/part_1

/usr/bin/../share/nmap/nselib/data/http-fingerprints.lua
"""
import os
import sys
import tty
import time
import queue
import select
import socket
import struct
import termios
import argparse
import netifaces
import threading

from io import BytesIO

from arp import parse_arp, process_arp
from dns_ import parse_dns_packet, process_dns_packet
from tls import parse_tls_payload, find_ja3_classification
from dhcp import parse_dhcp_packet, parse_dhcpv6_packet, extract_dhcp_client_details, match_dhcp_fingerprint
from icmp import parse_icmp, parse_icmpv6
from igmp import parse_igmp
from mdns import parse_mdns_packet, process_mdns_packet
from ssdp import parse_ssdp_packet
from http_ import parse_http, detect_service_banner
from tcp_udp import parse_eth_header, parse_ip_header, parse_tcp_header, parse_udp_header, parse_ipv6_header
from netbios import parse_netbios_packet, parse_netbios_datagram

from globals import MAGIC, CIGAM
from globals import DARK_RED, DEFAULT, CURSOR_TO_TOP, CLEAR_SCREEN_CURSOR_TO_TOP
from globals import ETH_P, ARP_P, ETH_P_ALL, ETH_IPV6
from globals import ETH_BCAST_ADDRESS, IPV6_ANY_ADDRESS
from globals import PCAP_GLOBAL_HEADER_ETHERNET, QUEUE_SIZE
from globals import Client, Flags
from globals import oui_table, oui_file, clients
from globals import is_private_ipv4, add_port, add_ttl

class interface:
    """
    Class to store and initialize system interface attributes.
    """
    interface_name = None
    mac = None
    ip = None
    gateway = None

    def __init__(self, name: str):
        self.interface_name = name
        if not self.interface_name: # This for read file mode
            self.mac = ""
            self.ip = ""
            self.gateway = ""
            return
        self.get_own_addresses()
        try:
            gateways = netifaces.gateways()
            self.gateway = gateways['default'][netifaces.AF_INET][0]
            self.gateway_mac = gateways['default']
        except KeyError:
            pass

    def get_own_addresses(self):
        """
        Method to retrieve layer 2 and 3 addressing from specified interface.
        """
        try:
            self.mac = netifaces.ifaddresses(self.interface_name)[netifaces.AF_LINK][0]['addr']
            self.ip = netifaces.ifaddresses(self.interface_name)[netifaces.AF_INET][0]['addr']
        except Exception as e:
            print('[!] ERROR: Please check the interface name and try again.')
            sys.exit(0)

class StatusInfo:
    """
    Function to store status information related to the
    Real-Time Display.
    """
    def __init__(self, interface):
        self.interface = interface
        self.start_time = time.time()
        self.status_message = ""
        self.message_printed = False
        self.pcap_read = ""

def hide_cursor() -> None:
    """
    Function to hide the cursor.
    """
    sys.stdout.write('\x1b[?25l')
    sys.stdout.flush()

def show_cursor() -> None:
    """
    Function to show the cursor.
    """
    sys.stdout.write('\x1b[?25h')
    sys.stdout.flush()

def key_press_listener(action) -> None:
    """
    Function to listen for key presses. Target of the key
    listener thread.
    """
    old_settings = termios.tcgetattr(sys.stdin)
    try:
        tty.setcbreak(sys.stdin.fileno())

        while not flags.exit_flag:
            if select.select([sys.stdin], [], [], 0.1)[0]:
                key_pressed = sys.stdin.read(1)
                if key_pressed:
                    action(key_pressed)
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

def handle_key_press(key: str) -> None:
    """
    Function to commit control actions after detecting specific
    key presses.
    """
    if key == '\x1b':  # ESC key
        print("ESC key pressed, exiting...                                             ")
        flags.exit_flag = True
        flags.q_pressed = True
    elif key.isdigit():
        #with flags.lock:
        #sys.stdout.write('\x1b[2J\x1b[H')
        sys.stdout.write(CLEAR_SCREEN_CURSOR_TO_TOP)
        if flags.key_code == int(key):
            flags.key_code = None
            flags.device_switch = False
        else:
            if flags.key_code is not None:
                flags.device_switch = True
            else:
                flags.device_switch = False
            flags.key_code = int(key)
        flags.q_pressed = False
    elif key == ' ':  # Checking for space bar key press
        if flags.paused:
            # If currently paused, unpause and restore any previously expanded device row
            sys.stdout.write("[-] Output unpaused                                     \r")
            flags.paused = False
            flags.q_pressed = False
            if flags.paused_device_selected is not None:
                flags.key_code = flags.paused_device_selected  # Restore the expanded view of the device
                flags.paused_device_selected = None
        else:
            # If not currently paused, pause the output and remember any currently expanded device row
            sys.stdout.write("[+] Output paused                                       \r")
            flags.paused = True
            if flags.key_code is not None:
                flags.paused_device_selected = flags.key_code  # Remember the currently expanded device
                flags.key_code = None  # No device row is expanded when paused
        flags.q_pressed = False
    elif key.lower() == 'q':
        if flags.q_pressed == True:
            flags.exit_flag = True
        else:
            sys.stdout.write("[!] Press 'q' again to quit. Press spacebar to continue.\r")
            flags.paused = True
            flags.q_pressed = True

def display_devices(clients_:dict, status_info: StatusInfo) -> None:
    """
    Function to print out details of the client class instances to the
    Real-Time Display. Target of thread.
    """
    # Define maximum widths for each column
    max_widths = {
        '#': 3, 'SOURCE': 19, 'IPv4': 14, 'IPv6': 30, 'MANUFACTURER': 20,
        'HOSTNAME': 20, 'SERVICES': 20, 'TTL': 4, 'OS': 15, 'CONNECTIONS': 15, 'PORTS': 6, 'COUNTS': 6
    }

    # Define the header and row formats using the maximum widths
    header_format = " ".join([f"{{:<{max_widths[col]}}}" for col in max_widths])
    header = header_format.format(*max_widths.keys())
    sys.stdout.write('\x1b[2J\x1b[H') # initial clear screen and move cursor to top left

    while not flags.exit_flag:

        clients_dict = clients_.copy()

        if not flags.paused:
            #with flags.lock:

            display_body = ""

            current_time = time.time()
            elapsed_time = int(current_time - status_info.start_time)
            elapsed_str = f"{elapsed_time // 60} min" if elapsed_time >= 60 else f"{elapsed_time} s"
            current_date_time = time.strftime('%Y-%m-%d %H:%M', time.localtime())

            if not flags.key_code:
                status_info.status_message = ""
                status_info.message_printed = False
            
            if flags.device_switch:
                status_info.status_message = ""
                status_info.message_printed = False
                flags.device_switch = False

            status_line = f"{status_info.interface} ][ Elapsed: {elapsed_str} ][ {current_date_time} {status_info.pcap_read} {status_info.status_message}"

            display_body += CURSOR_TO_TOP
            display_body += " " + status_line + '\n\n' 
            # Print the header
            display_body += " " + header + "\n"
            # Iterate through the clients dictionary and print each row
            for client_mac, client_data in clients_dict.items():
                client_dict = client_data.to_dict()  # Convert the client object to a dictionary
                
                # Prepare each value, truncate if necessary, convert None to '', and ensure alignment
                truncated_dict = {}
                for k, v in client_dict.items():
                    # If the field is one of 'OS', 'SERVICES', or 'PORTS' and is a set or list, take the first value
                    if k in ['SERVICES', 'PORTS', 'OS', 'HOSTNAME', 'CONNECTIONS']:
                        if v:
                            first_val = next(iter(v))  # Get the first value from the set/list
                            truncated_dict[k] = str(first_val)[:max_widths[k]]
                        else:
                            truncated_dict[k] = ''  # Set to empty string if the set is empty
                    else:
                        truncated_dict[k] = (str(v)[:max_widths[k]] if v is not None else '')

                # Format and print the row
                if flags.key_code and client_dict["#"] == flags.key_code:
                    display_body += DARK_RED
                formatted_row = header_format.format(*truncated_dict.values())
                display_body += " " + formatted_row + "\n"
                if flags.key_code and client_dict["#"] == flags.key_code:
                    if not status_info.message_printed:
                        status_info.status_message += f"][ + Device {flags.key_code} expanded"
                        status_info.message_printed = True
                    max_additional_rows = max(len(client_dict.get('SERVICES', [])), len(client_dict.get('HOSTNAME', [])), len(client_dict.get('PORTS', [])), len(client_dict.get('OS', [])), len(client_dict.get('CONNECTIONS', []))) - 1
                    for i in range(max_additional_rows):
                        additional_row = {k: '' for k in max_widths}  # Initialize with empty strings
                        for k in ['HOSTNAME', 'SERVICES', 'PORTS', 'OS', 'CONNECTIONS']:
                            values = list(client_dict.get(k, []))
                            if i + 1 < len(values):  # Check if there is a value to print in this additional row
                                additional_row[k] = str(values[i + 1])[:max_widths[k]]
                        # Format and print the additional row
                        formatted_additional_row = header_format.format(*additional_row.values())
                        display_body += " " + formatted_additional_row + "\n"
                if flags.key_code and client_dict["#"] == flags.key_code:
                    display_body += DEFAULT
            display_body += "\n"
            sys.stdout.write(display_body)
            sys.stdout.flush()
            time.sleep(.6)  # Update every half second
        else:
            pass

def is_multicast_or_broadcast(mac_address: str) -> bool:
    """
    Check if the MAC address is multicast or broadcast.
    """
    if mac_address == ETH_BCAST_ADDRESS:
        return True  # Broadcast address
    # Split the MAC address string into octets and take the first one
    first_octet_str = mac_address.split(':')[0]  # Assuming MAC address is separated by ':'
    # Convert the first octet to an integer
    first_octet_int = int(first_octet_str, 16)  # Convert from hexadecimal to integer
    # Multicast address check (LSB of first octet is 1)
    return (first_octet_int & 0x01) == 0x01

def load_oui() -> None:
    """
    Function to load an oui dictionary from an oui
    file. 
    """
    print('[+] Loading OUI tables')
    try:
        f_oui = open(oui_file, 'r')
        for line in f_oui:
            items = line.split(',')
            oui_table[items[1].lower()] = items[2]
    except FileNotFoundError:
        print(f'[!] File Not Found: {oui_file}')

def is_self_L2(packet_mac: str, iface_mac: str) -> bool:
    """
    Function to compare the source mac of a packet with the
    current system interface mac. Used to ignore packet coming
    from the system interface.
    """
    if packet_mac == iface_mac:
        return True
    else:
        return False
    
def is_self_L2_L3(packet_mac: str, iface: interface, packet_ip: str) -> bool:
    """
    Function to compare the source mac of a packet with the
    current system interface mac (and for layer 3 as well). 
    Used to ignore packet coming from the system interface.
    """
    if packet_mac == iface.mac and packet_ip == iface.ip:
        return True
    else:
        return False

def parse_packet(p: bytes, own_iface: interface, args) -> None:
    """
    Main packet parsing function. Processes Layer 2&^ headers by addressing
    protocols, and ports. 
    """

    GRAB_RESOURCES = args.resource_grab
    if args.read_pcap:
        GRAB_RESOURCES = False

    reader = BytesIO(p)
    eth_header = parse_eth_header(reader)

    if not is_self_L2(eth_header.src_mac, own_iface.mac):
        if eth_header.src_mac not in clients:
            cur_client = clients[eth_header.src_mac] = Client(eth_header.src_mac, flags.client_count)
            flags.client_count += 1
            if not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = None
        else:
            cur_client = clients.get(eth_header.src_mac)
            if not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = None

        # increase packet count for this client
        cur_client.count += 1

        if eth_header.eth_type == ARP_P:
            arp_packet = parse_arp(reader)
            process_arp(arp_packet, clients, flags)
            cur_client.protocols.add('ARP')
            return

        elif eth_header.eth_type == ETH_P:
            
            ip_header = parse_ip_header(reader)
            
            if is_private_ipv4(ip_header.src_ip):
                cur_client.ip_address = ip_header.src_ip

            if is_private_ipv4(ip_header.dst_ip) and not is_multicast_or_broadcast(eth_header.dst_mac):
                cur_client.communicants[eth_header.dst_mac] = ip_header.dst_ip

            if ip_header.protocol == 17: # UDP
                udp_header = parse_udp_header(reader)
                payload = reader.read(udp_header.payload_length)
                add_port(udp_header.src_port, cur_client)
                add_ttl(ip_header.ttl, udp_header.src_port, udp_header.dst_port, cur_client)

                if udp_header.src_port == 53 or udp_header.dst_port == 53: # DNS
                    dns_packet = parse_dns_packet(payload)
                    process_dns_packet(dns_packet, cur_client)
                    if not dns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('DNS')
                    return
                
                elif udp_header.src_port == 68:
                    dhcp_packet = parse_dhcp_packet(payload)
                    if not dhcp_packet:
                        write_packet(p, "ethodebug.pcap")
                    match_dhcp_fingerprint(dhcp_packet, cur_client)
                    extract_dhcp_client_details(dhcp_packet, cur_client)
                    cur_client.protocols.add('DHCP')
                    return

                elif udp_header.src_port == 137 or udp_header.dst_port == 137:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    if not nbns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-UDP-137')
                    return
                
                elif udp_header.src_port == 138 or udp_header.dst_port == 138:
                    nbns_packet = parse_netbios_datagram(payload)
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-UDP-138')
                    return

                elif udp_header.dst_port == 1900 or udp_header.src_port == 1900:
                    ssdp_packet = parse_ssdp_packet(payload, cur_client, flags.lock, GRAB_RESOURCES)
                    if not ssdp_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('SSDP')
                    return
                    
                elif udp_header.dst_port == 5353: # MDNS
                    mdns_packet = parse_mdns_packet(payload)
                    if not mdns_packet:
                        write_packet(p, "ethodebug.pcap")
                    process_mdns_packet(mdns_packet, cur_client)
                    cur_client.protocols.add('MDNS')
                    return

            elif ip_header.protocol == 6: # TCP
                tcp_header = parse_tcp_header(reader)
                tcp_header.payload_length = ip_header.total_length - ip_header.header_length - tcp_header.header_length
                payload = reader.read(tcp_header.payload_length)
                add_port(tcp_header.src_port, cur_client)
                add_ttl(ip_header.ttl, tcp_header.src_port, tcp_header.dst_port, cur_client)

                detect_service_banner(payload, cur_client)

                if b'GET' in payload or b'HTTP' in payload:
                    parse_http(payload, cur_client, flags.lock, GRAB_RESOURCES)
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('HTTP')
                    return                

                if tcp_header.dst_port == 22 or tcp_header.src_port == 22:
                    cur_client.protocols.add('SSH')
                    return
                
                if tcp_header.dst_port == 443: # HTTPS
                    tls_packet = parse_tls_payload(payload)
                    if not tls_packet:
                        write_packet(p, "ethodebug.pcap")
                    if tls_packet:
                        find_ja3_classification(tls_packet, cur_client)
                    cur_client.protocols.add('HTTPS')
                    return
                
                if tcp_header.src_port == 445 or tcp_header.dst_port == 445: # SMB
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('SMB')
                    return

                if tcp_header.src_port == 139:
                    nbns_packet = parse_netbios_packet(payload, cur_client)
                    if not nbns_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('NETBIOS-TCP-139')
                    return
                
            elif ip_header.protocol == 2: # IGMP
                igmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(igmp_payload_length)
                igmp_packet = parse_igmp(payload)
                if not igmp_packet:
                    write_packet(p, "ethodebug.pcap")
                cur_client.protocols.add('IGMP')
                return
            
            elif ip_header.protocol == 1: # ICMP
                cur_client.ttl = ip_header.ttl
                icmp_payload_length = ip_header.total_length - ip_header.header_length
                payload = reader.read(icmp_payload_length)
                icmp_packet = parse_icmp(payload)
                if not icmp_packet:
                    write_packet(p, "ethodebug.pcap")
                cur_client.protocols.add('ICMP')
                return
            
        elif eth_header.eth_type == ETH_IPV6:
            
            ipv6_header = parse_ipv6_header(reader)
            if not cur_client.ipv6_address and ipv6_header.src_ipv6 != IPV6_ANY_ADDRESS:
                cur_client.ipv6_address = ipv6_header.src_ipv6

            if ipv6_header.next_header == 17: # UDP
                udp_header = parse_udp_header(reader)
                payload = reader.read(udp_header.payload_length)
                
                if udp_header.src_port == 546:
                    dhcpv6_packet = parse_dhcpv6_packet(payload)
                    write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('DHCPv6')
                    return

                if udp_header.dst_port == 1900 or udp_header.src_port == 1900:
                    ssdp_packet = parse_ssdp_packet(payload, cur_client, flags.lock, GRAB_RESOURCES)
                    if not ssdp_packet:
                        write_packet(p, "ethodebug.pcap")
                    cur_client.protocols.add('SSDP')
                    return

                if udp_header.src_port == 5353: # MDNS
                    mdns_packet = parse_mdns_packet(payload)
                    if not mdns_packet:
                        write_packet(p, "ethodebug.pcap")
                    process_mdns_packet(mdns_packet, cur_client)
                    cur_client.protocols.add('MDNSv6')
                    return

            elif ipv6_header.next_header == 0 or ipv6_header.next_header == 58: #ICMPv6
                icmpv6_packet = parse_icmpv6(reader)
                if not icmpv6_packet:
                    write_packet(p, "ethodebug.pcap")
                cur_client.protocols.add('ICMPv6')
                return
            else:
                write_packet(p, "ethodebug.pcap")

def packet_reader(filename: str):
    """
    One of main threads. Function to read packets from file
    """
    header = None
    fcs_num_bytes = 0
    fcs_present = 0

    with open(filename, 'rb') as in_f:
        header = in_f.read(24)
        if len(header) < 24:
            print("ERROR: Incomplete file header.")
            flags.exit_flag = True
            return False

        # Unpack the global header
        magic, version_major, version_minor, thiszone, sigfigs, snaplen, linktype = struct.unpack('IHHIIII', header)

        linktype = linktype & 0x0FFFFFFF
        fcs_present = linktype & 0x10000000
        fcs_num_bytes = (linktype & 0xF0000000) << 1

        # Determine the file's endianness
        if magic == MAGIC:
            endianness = "<"  # Little endian
        elif magic == CIGAM:
            endianness = ">"  # Big endian
        else:
            print(f"ERROR: Unrecognized magic number: {magic}")
            flags.exit_flag = True
            return False

        count = 0
        ts_prev = None

        while not flags.exit_flag:
            pkt_header = in_f.read(16)
            if len(pkt_header) < 16:
                if len(pkt_header) == 0:
                    break  # End of file
                else:
                    print("ERROR: Incomplete packet header.")
                    break

            ts_s, ts_m, cap_len, orig_len = struct.unpack(endianness + 'IIII', pkt_header)
            ts_cur = ts_s + ts_m / 1e6  # Convert microseconds part to seconds and add

            pkt = in_f.read(cap_len)
            if len(pkt) < cap_len:
                print("ERROR: Incomplete packet data.")
                break

            # Handling Frame Check Sequence (FCS) if present
            if fcs_present:
                pkt = pkt[:-fcs_num_bytes]

            packet_queue.put(pkt)
            count += 1

            status_info.pcap_read = f"][ Packets read: {count}"

            if ts_prev is not None:
                time.sleep(ts_cur - ts_prev)  # Sleep for the duration between the current and previous packet

            ts_prev = ts_cur
    
    flags.exit_flag = True

def packet_parser(iface: interface, args) -> None:
    """
    One of main threads. Function pulls packets from the queue
    for parsing. 
    """
    while not flags.exit_flag:
        try:
            pkt = packet_queue.get(timeout=1)  # Timeout ensures that the loop checks the flag periodically
            parse_packet(pkt, iface, args)
            packet_queue.task_done()
        except queue.Empty:
            continue  # Continue checking the flag if the queue is empty

def packet_writer(filename: str | None) -> None:
    """
    One of main threads. Function pulls packets from dedicated queue
    for writing to file.
    """
    while flags.write_wait:
        try:
            pkt = write_queue.get(timeout=1)
            write_packet(pkt, filename)
            write_queue.task_done()
        except queue.Empty:
            continue

def packet_listener(iface: interface, filename: str | None):
    """
    One of main theads. Function reads raw packets from a socket,
    then writing them to a parsing and writing queue. 
    """
    s = None
    try:
        s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(ETH_P_ALL))
        s.bind((iface.interface_name, 0))
        print('[.] Listening for packets....')

        while not flags.exit_flag:
            pkt, addr = s.recvfrom(8192)
            packet_queue.put(pkt)
            if filename:
                write_queue.put(pkt)
    
    except KeyboardInterrupt:
        flags.exit_flag = True  # Signal all threads to exit
        print('\nCTRL+C pressed, shutting down...')
    except PermissionError:
        flags.exit_flag = True
        print('Permission Error: This script must be run with sudo.')
    except OSError:
        flags.exit_flag = True
        print(f'Error: Issue opening the socket on {iface.interface_name}.')
    finally:
        if s:
            s.close()

def write_packet(p: bytes, filename: str | None) -> None:
    """
    Function to write packets to a pcap file.
    """
    # Get the current time
    current_time = time.time()

    # Split the time into seconds and microseconds
    ts_seconds = int(current_time)
    ts_microseconds = int((current_time - ts_seconds) * 1_000_000)

    packet_length = len(p)
    packet_header = struct.pack('IIII', ts_seconds, ts_microseconds, packet_length, packet_length)
    f_out = open(filename, 'ab')
    f_out.write(packet_header)
    f_out.write(p)
    f_out.close()

def write_header(filename: str) -> None:
    """
    Function to write the global pcap file header.
    """
    f_out = open(filename, "wb")
    f_out.write(PCAP_GLOBAL_HEADER_ETHERNET)
    f_out.close()

if __name__ == "__main__":

    ed_argparse = argparse.ArgumentParser(prog='ethodump-ng', description='An Ethernet packet sniffing tool.')
    ed_argparse.version = '1.0'
    ed_argparse.add_argument('-i', '--interface', action='store', type=str, help='Enter the interface on which you want to sniff.', required=False)
    ed_argparse.add_argument('-w', '--write', action='store', type=str, help='Pass the file name to write packets.', required=False)
    ed_argparse.add_argument('-s', '--save', action='store', type=str, help='Pass the file name to save detailed results.', required=False)
    ed_argparse.add_argument('-r', '--resource-grab', action='store_true', help='Enable resource grabbing (Performs GET against resource urns).', required=False)
    ed_argparse.add_argument('-p', '--read-pcap', action='store', type=str, help='Pass a pcap file to read', required=False)
    ed_argparse.add_argument('-d', '--debug', action='store_true', help='Set the script debug to verbose.', required=False, default=False)
    ed_argparse.add_argument('-v', '--version', action='version')

    args = ed_argparse.parse_args()

    iface = None
    interface_name = ""
    # Set queues to None
    write_queue = None
    packet_queue = None
    # Number of consumer threads
    num_workers = 4
    # Initialize threads to Null
    write_thread = None
    worker_thread = None
    listener_thread = None
    display_thread = None
    keypress_thread = None

    if not args.interface and not args.read_pcap:
        print('ERROR: either --interface or --read must be specified.')
        sys.exit()

    if args.interface:
        interface_name = args.interface

    load_oui()

    # Initialize global interface object class
    iface = interface(interface_name)
    # Initialize global display status info and input control class
    status_info = StatusInfo(interface_name)
    # Initialize global flags class for signal management
    flags = Flags()
    # Initialize the queue(s)
    packet_queue = queue.Queue(QUEUE_SIZE)
    # Set the threading lock
    flags.lock = threading.Lock()
    
    hide_cursor()

    # temporary development mode measure
    if True:
        write_header("ethodebug.pcap")

    if args.read_pcap:
        if not os.path.exists(args.read_pcap):
            print(f'ERROR: File does not exist: {args.read_pcap}.')
            sys.exit()
        status_info.interface = args.read_pcap

    if args.write:
        write_header(args.write)
        write_queue = queue.Queue(QUEUE_SIZE)
        write_thread = threading.Thread(target=packet_writer, args=(args.write,))
        write_thread.daemon = True
        write_thread.start()

    # Start parser threads
    for _ in range(num_workers):
        worker_thread = threading.Thread(target=packet_parser, args=(iface,args,))
        worker_thread.daemon = True
        worker_thread.start()

    if args.read_pcap:
        # start the read thread
        read_thread = threading.Thread(target=packet_reader, args=(args.read_pcap,))
        read_thread.daemon = True
        read_thread.start()

    if not args.read_pcap:
        # Start the listener thread
        listener_thread = threading.Thread(target=packet_listener, args=(iface,args.write,))
        listener_thread.daemon = True
        listener_thread.start()

    if not args.debug:
        # Start the display thread
        display_thread = threading.Thread(target=display_devices, args=(clients, status_info,))
        display_thread.daemon = True
        display_thread.start()

    # Start the key press listener thread
    keypress_thread = threading.Thread(target=key_press_listener, args=(handle_key_press,))
    keypress_thread.daemon = True
    keypress_thread.start()

    try:
        while not flags.exit_flag:
            pass

    except KeyboardInterrupt:
        flags.exit_flag = True
        print("\nCTRL+C pressed, shutting down...")
    
    if write_thread:
        packets_left = write_queue.qsize()
        while write_queue.qsize() > 0:
            sys.stdout.write(f'\rFinishing writing packets to file: {write_queue.qsize() - 1}/{packets_left}     ')
            sys.stdout.flush()
        sys.stdout.write('\n\r')
        flags.write_wait = False
        write_thread.join(timeout=0.1)

    if args.debug:
        for client in clients:
            print(clients[client])

    if args.save:
        f_save = open(args.save, 'w')
        for client in clients:
            f_save.write(str(clients[client]) + '\n')
        f_save.close()
    
    show_cursor()
